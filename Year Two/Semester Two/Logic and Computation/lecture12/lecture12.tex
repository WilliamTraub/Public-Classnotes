\section{Invariants and Generalizing Modules}
We can create the type Even with the emergent inavariant property $\forall (n : even), n \mod 2 = 0$

We can equip our struct with a well-formedness property that ensures the invariance holds. This pushes some responsibility to the implementer and requires some hacking for testing. 

Instead we can define a CounterSig module and corresponding Counter that can be a fresh variable and "counts" how many times it gets bumped.

This counter lacks the ability to actually count as we do not have mutability. We can instead define CounterWithId with t as a record type that uses unique ids.

We currently have our count_evens function that can only work on Counter types but we might want to ma

For example: \begin{lstlisting}
  let read_network_string () : string = ...
  let read_local () : string = ...

  let process () : int =
    let s = read_network () in
    if s = "hello" the 0 else 1
\end{lstlisting}
This is an example of an application where we might want to make our process either read network or local. The desired solution to this problem is to parameterize our read function i.e.
\begin{lstlisting}
  let process (read: unit -> string) : int =
    let s = read () in
    if s = "hello" the 0 else 1
\end{lstlisting}
To extend this to modules we need a wrapper module. These are called functors (which are different from all other things called functors)

We can now write properties such as \textit{$\forall$ (c : CounterSig), get (bump c) = get c + 1}

There are some strange properties with polymorphism in this context. In the past we worked with MySetSig. We are reliant on the definition of equality where $\{(3, 2) (2, 3) \} = \{(2, 3)\}$

Our solution is to design a new definition of equality, a functor called EqType that has the equals property. Now we can parameterize our set struct with EqType, using a second type elem = T.t

We can now create UnorderedPair with an equals function. Even though we cannot annotate the type, the compiler infers this based on structure.
